from typing import Callable, Any, TypeVar, Iterable, Optional, Tuple


class HeavyBool:
    def __init__(self, because):
        self.because = because

    def __eq__(self, other):
        return other.because == self.because

    def Not(self) -> 'HeavyBool':
        raise NotImplemented

    def __add__(self, other) -> 'HeavyBool':
        raise NotImplemented

    def map(self, f: Callable[[str], str]) -> 'HeavyBool':
        raise NotImplemented

    def flatMap(self, f: Callable[[str], 'HeavyBool']):
        return f(self.because)

    def ifFalse(self, f: Callable[[str], 'HeavyBool']) -> 'HeavyBool':
        return self

    def mapIfTrue(self, f: Callable[[str], str]) -> 'HeavyBool':
        return self

    def mapIfFalse(self, f: Callable[[str], str]) -> 'HeavyBool':
        return self

    def ifTrue(self, f: Callable[[str], 'HeavyBool']) -> 'HeavyBool':
        return self


class HeavyTrue(HeavyBool):
    def __eq__(self, other):
        return isinstance(other, HeavyTrue) and super().__eq__(other)

    def __repr__(self):
        return f"True[{self.because}]"

    def __bool__(self):
        return True

    def Not(self):
        return HeavyFalse(self.because)

    def __add__(self, because):
        return HeavyTrue(self.because + " " + because)

    def map(self, f: Callable[[str], str]) -> 'HeavyBool':
        return HeavyTrue(f(self.because))

    def ifTrue(self, f: Callable[[str], 'HeavyBool']) -> 'HeavyBool':
        return self.flatMap(f)

    def mapIfTrue(self, f: Callable[[str], str]) -> 'HeavyBool':
        return self.ifTrue(lambda str: HeavyFalse(f(str)))


class HeavyFalse(HeavyBool):
    def __eq__(self, other):
        return isinstance(other, HeavyTrue) and super().__eq__(other)

    def __repr__(self):
        return f"False[{self.because}]"

    def __bool__(self):
        return False

    def __add__(self, because) -> 'HeavyBool':
        return HeavyFalse(self.because + " " + because)

    def Not(self):
        return HeavyTrue(self.because)

    def map(self, f: Callable[[str], str]) -> 'HeavyBool':
        return HeavyFalse(f(self.because))

    def ifFalse(self, f: Callable[[str], 'HeavyBool']) -> 'HeavyBool':
        return self.flatMap(f)

    def mapIfFalse(self, f: Callable[[str], str]) -> 'HeavyBool':
        return self.ifFalse(lambda str: HeavyFalse(f(str)))


def existsM(items, p: Callable[[Any], HeavyBool]) -> HeavyBool:
    for i in items:
        r = p(i)
        if r:
            return HeavyTrue(f"example {i} because {r.because}")

    return HeavyFalse("")


def forallM(items, p: Callable[[Any], HeavyBool]) -> HeavyBool:
    return existsM(items, lambda i: p(i).Not()).Not()


print(HeavyTrue("xxx") or HeavyFalse("yyy"))
print(HeavyFalse("yyy") or HeavyTrue("xxx"))
print(HeavyTrue("xxx") and HeavyFalse("yyy"))
print(HeavyFalse("yyy") and HeavyTrue("xxx"))

print(existsM([HeavyTrue("xxx"), HeavyFalse("yyy")],
              lambda i: i))
